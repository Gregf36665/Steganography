First ideas
=============

I plan to use an 8-bit picture meaning that the picutre uses 8 bits per color.  
I would set up the bits in an arbatary form; from high to low:

  RGBA:
    (255,255,255,0)
      (11111111,11111111,11111111,00000000)

In this form 2 = 00000010 rather than 01000000

According to my research a change in one bit for each channel would be unnoticable by a human eye.
This means that I can hide at most, a picture an eighth of the size of the 'cover' photo.
This is from the fact that for every byte of the cover picture I can only change one bit.


Formulas
=========

I need a way to import the picture into matlab and convert the matrix into a binary matrix.
The first command I will need to use would be:

  imread('picture','filetype);

This will import the data of the picture as a data stream of bytes (0-255).

To turn this into bits I need to use of:

  dec2bin(number)

The problem with this is that it removes any dimensions and leaves a string of numbers.
To solve this the command:

  size(array)

is useful as it will give me the three dimensions of the pictures (length, width, bytes per pixle)

Deal with the file to hide
===========================

To hide the file the first thing I need to do is import it as a data stream.
After that I change it to a binary stream.

From here I need to take the first three bits and change the last bits in the first three bytes.
This modification is an XOR relationship with a truth table:

 A | B | Out
---+---+----
 0 | 0 |  0
---+---+----
 0 | 1 |  1
---+---+----
 1 | 0 |  1
---+---+----
 1 | 1 |  0


Prototype 2013-11-01
=====================

For the first prototype I wanted to encode 1 bit in a 1 by 1 picture (3 byte).
I wanted to attempt to set up a for loop that could deal with multiple bits to encrypt.
The first step I did was to find the sizes of the different dimensions.
The word size is reserved and causes problems if it is declared as a variable.

To solve the XOR addition I used:

XOR(A,B)

where A = cover_bin(8*n)%2 and B = hidden(n)

I made a loop until n >= numelm(cover)/8

  numelm(X) ==> the number of elements in X
