First ideas
=============

I plan to use an 8-bit picture meaning that the picutre uses 8 bits per color.  
I would set up the bits in an arbatary form; from high to low:

  RGBA:
    (255,255,255,0)
      (11111111,11111111,11111111,00000000)

In this form 2 = 00000010 rather than 01000000

According to my research a change in one bit for each channel would be unnoticable by a human eye.
This means that I can hide at most, a picture an eighth of the size of the 'cover' photo.
This is from the fact that for every byte of the cover picture I can only change one bit.


Formulas
=========

I need a way to import the picture into matlab and convert the matrix into a binary matrix.
The first command I will need to use would be:

  imread('picture','filetype);

This will import the data of the picture as a data stream of bytes (0-255).

To turn this into bits I need to use of:

  dec2bin(number)

The problem with this is that it removes any dimensions and leaves a string of numbers.
To solve this the command:

  size(array)

is useful as it will give me the three dimensions of the pictures (length, width, bytes per pixle)

Deal with the file to hide
===========================

To hide the file the first thing I need to do is import it as a data stream.
After that I change it to a binary stream.

From here I need to take the first three bits and change the last bits in the first three bytes.
This modification is an XOR relationship with a truth table:

 A | B | Out
---+---+----
 0 | 0 |  0
---+---+----
 0 | 1 |  1
---+---+----
 1 | 0 |  1
---+---+----
 1 | 1 |  0


Prototype 2013-11-01
=====================

For the first prototype I wanted to encode 1 bit in a 1 by 1 picture (3 byte, no alpha).
I wanted to attempt to set up a for loop that could deal with multiple bits to encrypt.
The first step I did was to find the sizes of the different dimensions.
The word size is reserved and causes problems if it is declared as a variable.

To solve the XOR addition I used:

  XOR(A,B)

where A = cover_bin(8*n)%2 and B = hidden(n)

I made a loop until n >= numelm(cover)/8

  numelm(X) ==> the number of elements in X
  
After running the prototype I realised I need to reserve the first few bytes for the dimensions of the hidden file.
I recorded the dimensions of the matrix produced and returned the length and width as different variables

Minimum bits for the dimensions 2013-11-01 
===========================================

To figure out the mimimum amount of bits required to remember the dimensions I used:

floor(log2(X)+1);

where X is the dimension.
The floor command lowers the value to the nearest whole number.

Decryption
==========

To be able to decrypt the picture without the original there needs to be some type of convention for the code.  I dedicated the first 2 bytes to the height and the next two to the width and then after that I would use the rest for the code.  The first 4 bytes would be set to either 1 or 0 to say the height and width but after that the bits would be exclusivly added.

Test 2013-11-03
================

I modifyed the code to take pictures in rather than predefined matrixes and I managed to sucsessfully see a picture output for the height and width data.

Future plans
============

It is possible that could set the bit rather than flip the bit to be able to decrypt the image.
Extracting the image would be significantly easier to do.

Final project 2013-11-04
=========================

I have managed to create a program that can hide a picture inside another image and sucsessfully extract the image out again
Now I need to work with audio

Audio 2013-11-06
================

To extract the sound I need the samples and the sample rate:

[y , fs] = wavread('file.wav");

This imports the sample as y in an N x 2 matrix (L/R channel) and fs as the samples per second.
I plan to use the red channel for left and the green channel for right and the blue channel for sample rate.

One issue is that the value for y is between -1 and 1 but I want it between 0 and 255.
I need to figure out a way to encode the data in such a way that the negative numbers are <128 and positive is >=128.

Bits per sample 2013-11-10
===========================

After examinine the file I realised that there were actually 16 bits per sample not 8 so I actually needed a number between:
0 and 65535 (2^16-1)

The first plan should be to build an encoded and decoder for audio to bits and back.
Maybe save it as a function and then call it in the larger project.

